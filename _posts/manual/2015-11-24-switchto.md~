---
layout: post
title: 宏switch_to分析
description: 真的是这辈子都不想看这段代码。。。。
category: manual
---

##引

首先来看下一些基本要点：
<ul>
<li>linux内核2.6以后进程使用软切换。</li>
<li>进程切换一定发生在内核态，也就是这个时候用户态的运行现场已经保存在内核栈里。</li>
<li>每个进程不再独有tss描述符，硬件上下文一部分保存在thread_struct结构中，还有一部分保存内核栈中。</li>
<li>thread_struct中使用到的基本就是esp，esp0，eip，iomap。esp保存当前栈顶偏移，切入时对应恢复到esp寄存器；esp0保存此内核栈栈底偏移，对应恢复到tss的esp0；eip表示切入后第一条执行的指令，对应恢复到eip寄存器（然而情况不是那么简单）</li>
<li>thread_struct中不包括ss0即内核堆栈段，因为为了效率，所有的进程内核堆栈段都是相同的，在初始化cpu的tss时统一设置为_KERNEL_DS，且在整个系统生命周期中不改变。</li>
</ul>


还有就是内核切换进程时可以用一句话来概括：从switch_to中来，从switch_to中走。


##分析
先看下调用关系：schedule() --> context_switch() --> switch_to --> __switch_to()

	 //arch/x86/include/asm/switch_to.h 
	 31 #define switch_to(prev, next, last)                 \
	 32 do {                                    \
	 33     /*                              \
	 34      * Context-switching clobbers all registers, so we clobber  \
	 35      * them explicitly, via unused output variables.        \
	 36      * (EAX and EBP is not listed because EBP is saved/restored \
	 37      * explicitly for wchan access and EAX is the return value of   \
	 38      * __switch_to())                       \
	 39      */                             \
	 40     unsigned long ebx, ecx, edx, esi, edi;              \
	 41                                     \
	 42     asm volatile("pushfl\n\t"       /* save    flags */ \
	 43              "pushl %%ebp\n\t"      /* save    EBP   */ \
	 44              "movl %%esp,%[prev_sp]\n\t"    /* save    ESP   */ \
	 45              "movl %[next_sp],%%esp\n\t"    /* restore ESP   */ \
	 46              "movl $1f,%[prev_ip]\n\t"  /* save    EIP   */ \
	 47              "pushl %[next_ip]\n\t" /* restore EIP   */ \
	 48              __switch_canary                    \
	 49              "jmp __switch_to\n"    /* regparm call  */ \
	 50              "1:\t"                     \
	 51              "popl %%ebp\n\t"       /* restore EBP   */ \
	 52              "popfl\n"          /* restore flags */ \
	 53                                     \
	 54              /* output parameters */                \
	 55              : [prev_sp] "=m" (prev->thread.sp),        \
	 56                [prev_ip] "=m" (prev->thread.ip),        \
	 57                "=a" (last),                 \
	 58                                     \
	 59                /* clobbered output registers: */        \
	 60                "=b" (ebx), "=c" (ecx), "=d" (edx),      \
	 61                "=S" (esi), "=D" (edi)               \
	 62                                         \
	 63                __switch_canary_oparam               \
	 64                                     \
	 65                /* input parameters: */              \
	 66              : [next_sp]  "m" (next->thread.sp),        \
	 67                [next_ip]  "m" (next->thread.ip),        \
	 68                                         \
	 69                /* regparm parameters for __switch_to(): */  \
	 70                [prev]     "a" (prev),               \
	 71                [next]     "d" (next)                \
	 72                                     \
	 73                __switch_canary_iparam               \
	 74                                     \
	 75              : /* reloaded segment registers */         \
	 76             "memory");                  \
	 77 } while (0)

不得不说这个宏真的非常的神奇，首先推荐看下这篇文章<a href="http://www.cnblogs.com/zhuyp1015/archive/2012/05/01/2478099.html">Gcc内嵌汇编基础</a></li>
